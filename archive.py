import glob
import json
import logging
import os
from subprocess import Popen, PIPE
import yaml
import re

config = {}
data = {}

dir = os.path.dirname(os.path.realpath(__file__))
logging.basicConfig(
    filename=os.path.join(dir, "log"),
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S")

# load the config file
with open("config.json", "r") as config_file:
    config = json.load(config_file)

# load from existing data file
if os.path.exists(config["data_file"]):
    with open(config["data_file"], "r") as file:
        data = json.load(file)

paths = []

for root, dirs, files in os.walk(config["root_dir"]):
    for dir in dirs:
        if dir.startswith("."):
            dirs.remove(dir)

    if ("backup.yml" in files):
        manifest_path = os.path.join(root, "backup.yml")
        patterns = yaml.load(open(manifest_path, "r"))

        if patterns is None or "include" not in patterns:
            continue

        get_normpath = lambda path: os.path.normpath(os.path.join(os.path.dirname(os.path.realpath(__file__)), root, path))

        get_glob_paths = lambda key: [path.replace("\\", "/") for paths in [glob.glob(get_normpath(pattern)) for pattern in patterns[key] or []] for path in paths]

        exclude_paths = get_glob_paths("exclude") if "exclude" in patterns else []
        include_paths = [get_normpath(path) for path in get_glob_paths("include") if path not in exclude_paths]

        paths += include_paths

        for path in paths:
            match = re.match("\/([^ \/]+)$", path)
            if match and match.group(1) in dirs:
                dirs.remove(dir)
        
print(paths)

# # handle each pattern
# for pattern in config["patterns"]:
#     logging.debug("Checking pattern {}".format(pattern))

#     results = glob.glob(pattern)

#     # handle all the results generated by the pattern
#     for result in results:
#         logging.debug("Checking result {} for pattern {}".format(result, pattern))

#         m_time = os.path.getmtime(result)  # get the last modified time
        
#         # if the result is not yet tracked or has changed since last entry, update the archive
#         if result not in data or (result in data and data[result] < m_time):
#             logging.debug("Updating result {} for pattern {}".format(result, pattern))
            
#             data[result] = m_time

#             # archive with 7zip
#             process = Popen(
#                 "{} a \"{}.zip\" \"{}\"".format(
#                     config["7z_path"],
#                     os.path.normpath(config["archive_directory"] + "/" + result),
#                     result),
#                 stdin=PIPE,
#                 stdout=PIPE,
#                 shell=True)

#             out, err = process.communicate()
#             logging.debug(out)
#             if err is not None:
#                 logging.warning(err)
            

# # write back the data file
# with open(config["data_file"], "w") as file:
#     json.dump(data, file)
